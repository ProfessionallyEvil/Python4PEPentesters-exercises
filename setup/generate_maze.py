#!/usr/bin/python

# Generate a maze...
# This is an incomplete / work in progress.  The idea is to generate a simple MUD style program that students
# can connect to and interact with.  Assume a very large maze (e.g. 1000 x 1000 grid), in which case automating
# interaction with it will solve the maze much faster than manually.
import socketserver

import random
import sys

maze = []
rows = 10
cols = 10
maze_enter = (0, random.randint(1, cols-1))
maze_exit = (rows-1, random.randint(1, cols-1))
back = {'n': 's', 's': 'n', 'e': 'w', 'w': 'e'}

# set up walls everywhere
for r in range(0, rows):
    maze.append([])
    for _ in range(0, cols):
        maze[r].append(set([]))

# knock down walls
l_stack = [maze_enter]

while len(l_stack) > 0:
    cell = l_stack.pop()
    row = cell[0]
    col = cell[1]

    spaces = maze[row][col]
    options = []
    # check n
    if row-1 > 0 and 'n' not in spaces:
        if len(maze[row-1][col]) == 0:
            options.append(('n', row-1, col))
    # check e
    if col < cols-1 and 'e' not in spaces and row > 0:
        if len(maze[row][col+1]) == 0:
            options.append(('e', row, col+1))
    # check s
    if row < rows-1 and 's' not in spaces:
        if len(maze[row+1][col]) == 0:
            options.append(('s', row+1, col))
    # check w
    if col-1 > 0 and 'w' not in spaces and row > 0:
        if len(maze[row][col-1]) == 0:
            options.append(('w', row, col-1))

    if len(options) > 0:
        chosen = random.choice(options)
        new_r = chosen[1]
        new_c = chosen[2]
        maze[row][col] |= {chosen[0]}        # add chosen direction to current cell
        maze[new_r][new_c] |= {back.get(chosen[0])}  # add back direction to next cell
        l_stack.append((row, col))  # put current cell back on stack
        l_stack.append((new_r, new_c))  # put next cell on top of stack

# output the maze
for r in range(0, rows):
    h_walls = '#'
    v_walls = '#'
    for c in range(0, cols):
        if 'e' in maze[r][c]:
            h_walls += '  '
        elif r == 0 and c != maze_enter[1]:
            h_walls += '##'
        else:
            h_walls += ' #'
        if 's' in maze[r][c]:
            v_walls += ' #'
        else:
            v_walls += '##'
    print (h_walls)
    print (v_walls)

class MazeServer(socketserver.BaseRequestHandler):
    def handle(self):
        location = (maze_enter[0], maze_enter[1])
        self.data = ''
        self.request.sendall("Welcome to the Maze.  Use n, e, s, w to navigate.")

        while self.data != 'exit':
            exits = self.options(location)
            direction = self.data.strip().lower()
            if direction in exits:
                if direction == 'n':
                    location = (location[0], location[1]-1)
                elif direction == 'e':
                    location = (location[0]+1, location[1])
                elif direction == 's':
                    location = (location[0], location[1]+1)
                elif direction == 'w':
                    location = (location[0]-1, location[1])
                else:
                    print ('%s unrecognized' % direction)

            elif direction in ['n','s','e','w']:
                self.request.sendall('\nYou hit a wall')
            else:
                self.request.sendall("\nYou can't do that now")

            self.request.sendall("\n%s" % self.print_options(exits))
            self.data = self.request.recv(1024).strip()
            print ("{} wrote:".format(self.client_address[0]))
            print (self.data)

    def options(self, location):
        exits = []
        for x in maze[location[0]][location[1]]:
            exits.append(x)
        return exits

    def print_options(self, ops):
        s = 'From here you may go: '
        for o in ops:
            s += o
            s += ' '
        return s




HOST, PORT = "0.0.0.0", 10042

if len(sys.argv) > 0 and sys.argv[0].isdigit():
    PORT = int(sys.argv[0])

# Create the server, binding to localhost on port 1042
server = socketserver.TCPServer((HOST, PORT), MazeServer)

# Activate the server; this will keep running until you interrupt the program with Ctrl-C
print ('Starting maze server on ' + HOST + ':' + str(PORT))
server.serve_forever()