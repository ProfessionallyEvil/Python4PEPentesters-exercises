# Exercise: Often at the start of a penetration test we are given a list of target networks in mixed formats:
# - some CIDR (e.g. 10.1.2.0/24)
# - some dashed ranges (e.g. 172.16.1.5-25)
# - some individual addresses
# Some tools can't deal with mixed formats, or simply require just a list of hosts.  Build a tool that converts a list
# of networks into a list of host addresses.

# Regex patterns to help recognize entries:
# cidr_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{2}$")
# ipv4_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$")
# dash_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}-[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$")

# Hints:
# - Use the regex patterns above to determine what type of pattern is on a given line.
# - Use the files/networks.txt file as a test
# - Use argparse to turn this into a useful commandline utility that can specify input and output arguments

import netaddr
import re


def parse_cidr(line):
    network = netaddr.IPNetwork(line)
    for ip in list(network):
        print(ip)


def parse_range(line):
    ip_range = line.split('-')
    network = netaddr.iter_iprange(ip_range[0], ip_range[1])
    for ip in list(network):
        print(ip)


if __name__ == '__main__':
    cidr_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{2}$")
    ipv4_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$")
    dash_pattern = re.compile("^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}-[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$")

    f = open('../../files/networks.txt')
    for line in f.readlines():
        line = line.strip()
        if cidr_pattern.search(line) is not None:
            parse_cidr(line)
        elif dash_pattern.search(line) is not None:
            parse_range(line)
        elif ipv4_pattern.search(line) is not None:
            print(line)
