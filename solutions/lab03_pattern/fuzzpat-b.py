
# Create a procedure that, given the parameter 'length', generates the pattern
# 'Aa0Aa1Aa2Aa3Aa4Aa5', etc... of the the supplied length.
def generate_pattern(length):
    upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lower = upper.lower()
    digits = '0123456789'

    pattern = ''

    for u in upper:
        for l in lower:
            for d in digits:
                pattern += u
                if len(pattern) == length:
                    return pattern
                pattern += l
                if len(pattern) == length:
                    return pattern
                pattern += d
                if len(pattern) == length:
                    return pattern
# STEP B:
# Create a second procedure that, given the parameters 'address' and 'max' (defaults to 10000), will:
# a) convert the hex-based pattern fragment into its ascii equivalent (let's call that the 'token')
# b) reverse the token, to account for little endian
# c) generate a pattern of size 'max'
# d) return the index the token in the pattern, or an appropriate error message if the token is not found

def pattern_locate(pattern_hex, max=1000):
    pattern_ascii = bytes.fromhex(pattern_hex).decode('ascii')[::-1]

    pattern = generate_pattern(max)
    return pattern.find(pattern_ascii)


# Use a __name__ == "__main__" block to test the procedure.
if __name__ == '__main__':
    # print(generate_pattern(200))
    print(pattern_locate(''))  # HARDCODE the location from the buffer overflow emulator