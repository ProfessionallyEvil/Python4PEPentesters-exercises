#!/usr/bin/python

# Generate a locator pattern for buffer overflow discovery and exploitation.

import argparse

alpha_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
alpha_lower = 'abcdefghijklmnopqrstuvwxyz'
numeric = '0123456789'

def generate(length):
  pattern = ''
  while len(pattern) < length:
    for u in alpha_upper:
      for l in alpha_lower:
        for n in numeric:
          if len(pattern) < length:
            pattern += u
          if len(pattern) < length:
            pattern += l
          if len(pattern) < length:
            pattern += n
  return pattern


if __name__ == "__main__":
  parser = argparse.ArgumentParser(description='Generate or locate a fuzz pattern.')
  subparsers = parser.add_subparsers()

  parser_generate = subparsers.add_parser('generate', help='Generate a pattern of a specified length')
  parser_generate.add_argument('length', type=int, help='The length of the pattern to generate.')

  parser_locate = subparsers.add_parser('locate', help='Locate the given pattern')
  parser_locate.add_argument('pattern', help='The pattern to locate.')
  parser_locate.add_argument('--max', type=int, default=10000, help='The maximum size to look for (default=10000).')
  parser_locate.add_argument('--type', choices=['ascii','address'], default='address', help='Is this an address(default) or ascii value passed in?')

  args = parser.parse_args()
  if hasattr(args, 'length'):
    print ('Generating pattern of length %i' % args.length)
    pattern = generate(args.length)
    print (pattern)

  if hasattr(args, 'pattern'):
    pattern = generate(args.max)
    to_find = args.pattern
    if args.type == 'address':
      to_find = args.pattern.decode('hex')[::-1]
      print ('Converting address %s to value %s' % (args.pattern, to_find))
    print ('Locating pattern %s in (max=%i, use --max to change)' % (to_find, args.max))
    print ('Index of pattern: %i' % pattern.find(to_find))

