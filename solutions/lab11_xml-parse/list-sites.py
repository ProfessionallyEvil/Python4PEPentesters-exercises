#!/usr/bin/python

# This application parses website URLs out of a standard Nessus (XML) output file.
# Nessus plugin id 22964 is used to identify services
# This is a subclass of the standard ContentHandler class.  This is what implements the callbacks
# that the parser will use as it parses through the file.
import xml.sax
import re
import socket
import argparse


class NessusContentHandler(xml.sax.ContentHandler):
    www_services = ['www', 'http?', 'https?']
    plugins = ['22964']
    current_host = ''
    current_port = ''
    plugin_output = ''
    tag = ''
    is_web_host = False
    results = []

    # The startElement callback will store the currentPluginID and currentPort for ReportItem tags.
    # It will also store the name for ReportHost
    def startElement(self, name, attrs):
        self.tag = name
        if name == "ReportItem":
            self.plugin_output = ''
            id = attrs['pluginID']
            svc = attrs['svc_name']
            if id in self.plugins and svc in self.www_services:
                self.current_port = attrs['port']
                self.is_web_host = True
            else:
                self.is_web_host = False
        elif name == "ReportHost":
            self.current_host = attrs['name']

    # The characters callback gets called for every text node encountered in the xml.  We want to capture
    # just those that are listed in the tagsWithText list.  It is possible for text nodes to be parsed in
    # chunks and for them to contain whitespace, so we need to accommodate these situations.
    def characters(self, content):
        if self.tag == 'plugin_output' and len(content.strip()) > 0:
            self.plugin_output += content

    # The endElement callback will be our cue to save a result set if the name is ReportItem.  We also want
    # to reset our temporary textValues.
    def endElement(self, name):
        if name == "ReportItem" and self.is_web_host:
            proto = guess_proto(self.plugin_output)
            name = lookup_name(self.current_host)
            url =  '%s://%s:%s' % (proto, name, self.current_port)
            if url not in self.results:
                self.results.append(url)

    def getResults(self):
        return self.results


def guess_proto(output):
    # optimized portion of Peeper (https://github.com/invisiblethreat/peeper) by Scott Walsh (@blacktip)
    secure = re.search('TLS|SSL', output)
    if secure:
        return "https"
    return "http"


def lookup_name(ip):
    try:
        x = socket.gethostbyaddr(ip)
        if len(x[0]) > -1:
            return x[0]
        else:
            return ip
    except:
        return ip


def main():
    ap = argparse.ArgumentParser(description='Extract URLs from Nessus report(s)')
    ap.add_argument('infile', help='The Nessus xml to be parsed.')
    ap.add_argument('--html', action='store_true')
    args = ap.parse_args()

    parser = xml.sax.make_parser()
    content_handler = NessusContentHandler()
    parser.setContentHandler(content_handler)
    parser.parse(open(args.infile, 'r'))

    results = content_handler.getResults()
    if args.html:
        print ('<html><head></head><body>\n<ul>')
        for result in results:
            print ('  <li><a href="%s">%s</a></li>' % (result, result))
        print ('</body></html>')
    else:
        for result in results:
            print (result)


if __name__ == "__main__":
    main()


